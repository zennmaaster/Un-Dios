package com.castor.agent.orchestrator

import com.castor.core.common.model.AgentType
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import javax.inject.Inject
import javax.inject.Singleton

// =========================================================================================
// Data models
// =========================================================================================

/**
 * A proactive insight generated by the engine for display on the home screen.
 *
 * @param id        Unique identifier for deduplication and dismissal.
 * @param message   Human-readable insight text shown to the user.
 * @param priority  Importance level for ordering.
 * @param agentType The agent domain that generated this insight.
 * @param timestamp When the insight was created (epoch millis).
 * @param action    Optional action the user can take when tapping the insight.
 */
data class ProactiveInsightItem(
    val id: String = UUID.randomUUID().toString(),
    val message: String,
    val priority: InsightPriority,
    val agentType: AgentType,
    val timestamp: Long = System.currentTimeMillis(),
    val action: ProactiveAction? = null
)

/**
 * Actions that can be attached to a [ProactiveInsightItem]. When the user taps
 * an insight, the UI layer executes the associated action.
 */
sealed class ProactiveAction {

    /**
     * Navigate to a specific route in the app (e.g. "messages/unread", "media/player").
     */
    data class NavigateTo(val route: String) : ProactiveAction()

    /**
     * Send a command string to the [AgentOrchestrator] for processing.
     */
    data class SendCommand(val command: String) : ProactiveAction()

    /**
     * No action beyond dismissing the insight.
     */
    data object DismissOnly : ProactiveAction()
}

// =========================================================================================
// ProactiveEngine
// =========================================================================================

/**
 * Rules engine that listens to the [AgentEventBus] and generates proactive insights
 * for the user. Insights are surfaced on the home screen and auto-expire after
 * [INSIGHT_EXPIRY_MS].
 *
 * Rate limiting ensures that each agent can produce at most one insight every
 * [RATE_LIMIT_MS] to avoid overwhelming the user.
 *
 * Rules:
 * - Urgent message -> high-priority insight
 * - Calendar event within 15 min -> medium-priority insight
 * - Reminder fired -> high-priority insight
 * - Media stopped after long session -> low-priority suggestion
 * - Battery low -> medium-priority warning
 * - Bluetooth connected -> low-priority suggestion
 */
@Singleton
class ProactiveEngine @Inject constructor(
    private val eventBus: AgentEventBus
) {

    companion object {
        /** Insights auto-expire after 30 minutes. */
        private const val INSIGHT_EXPIRY_MS = 30L * 60 * 1000

        /** Rate limit: max 1 insight per agent per 5 minutes. */
        private const val RATE_LIMIT_MS = 5L * 60 * 1000

        /** How often the expiry sweep runs. */
        private const val EXPIRY_CHECK_INTERVAL_MS = 60_000L

        /**
         * Minimum media play session duration (in millis) before suggesting "continue
         * listening" after playback stops.
         */
        private const val LONG_PLAY_SESSION_MS = 10L * 60 * 1000

        /** Maximum insights to keep in the list. */
        private const val MAX_INSIGHTS = 20
    }

    // -------------------------------------------------------------------------------------
    // Internal state
    // -------------------------------------------------------------------------------------

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

    /** The active list of proactive insights. */
    private val _proactiveInsights = MutableStateFlow<List<ProactiveInsightItem>>(emptyList())

    /** Last time an insight was emitted per agent type (for rate limiting). */
    private val lastInsightTime = ConcurrentHashMap<AgentType, Long>()

    /** Tracks when media playback started, to detect "long play sessions". */
    @Volatile
    private var mediaPlayStartTime: Long = 0L

    /** Tracks the last known media title for "continue listening" suggestions. */
    @Volatile
    private var lastMediaTitle: String? = null

    /** Tracks the last known media artist. */
    @Volatile
    private var lastMediaArtist: String? = null

    /** The monitoring job; cancelled in [stop]. */
    private var monitoringJob: Job? = null

    /** The expiry sweep job. */
    private var expiryJob: Job? = null

    // -------------------------------------------------------------------------------------
    // Public API
    // -------------------------------------------------------------------------------------

    /**
     * Observable list of current proactive insights, ordered by priority (HIGH first)
     * then by recency (newest first within the same priority).
     */
    val proactiveInsights: StateFlow<List<ProactiveInsightItem>> =
        _proactiveInsights.asStateFlow()

    /**
     * Start the monitoring loop. Call this from [AgentService.onCreate].
     * Safe to call multiple times -- subsequent calls are no-ops if already running.
     */
    fun start() {
        if (monitoringJob?.isActive == true) return

        monitoringJob = scope.launch {
            eventBus.events.collect { event ->
                processEvent(event)
            }
        }

        expiryJob = scope.launch {
            while (isActive) {
                delay(EXPIRY_CHECK_INTERVAL_MS)
                expireOldInsights()
            }
        }
    }

    /**
     * Stop monitoring. Call this from [AgentService.onDestroy].
     */
    fun stop() {
        monitoringJob?.cancel()
        monitoringJob = null
        expiryJob?.cancel()
        expiryJob = null
    }

    /**
     * Dismiss a specific insight by its [id].
     */
    fun dismissInsight(id: String) {
        _proactiveInsights.value = _proactiveInsights.value.filter { it.id != id }
    }

    /**
     * Clear all insights.
     */
    fun clearAll() {
        _proactiveInsights.value = emptyList()
    }

    // -------------------------------------------------------------------------------------
    // Event processing -- rules engine
    // -------------------------------------------------------------------------------------

    private fun processEvent(event: AgentEvent) {
        when (event) {
            is AgentEvent.NewMessage -> handleNewMessage(event)
            is AgentEvent.CalendarEventSoon -> handleCalendarEvent(event)
            is AgentEvent.ReminderFired -> handleReminderFired(event)
            is AgentEvent.MediaStateChanged -> handleMediaStateChanged(event)
            is AgentEvent.SystemEvent -> handleSystemEvent(event)
            is AgentEvent.ProactiveInsight -> handleAgentInsight(event)
            // Health checks, model lifecycle events are not acted on by the proactive engine
            is AgentEvent.AgentHealthCheck -> { /* monitored by AgentHealthMonitor */ }
            is AgentEvent.ModelLoaded -> { /* informational */ }
            is AgentEvent.ModelUnloaded -> { /* informational */ }
        }
    }

    // ---- Rule: Urgent message ----

    private fun handleNewMessage(event: AgentEvent.NewMessage) {
        if (!event.isUrgent) return

        addInsight(
            ProactiveInsightItem(
                message = "Urgent message from ${event.sender}: \"${truncate(event.content, 60)}\"",
                priority = InsightPriority.HIGH,
                agentType = AgentType.MESSAGING,
                action = ProactiveAction.NavigateTo("messages/conversation/${event.sender}")
            )
        )
    }

    // ---- Rule: Calendar event approaching ----

    private fun handleCalendarEvent(event: AgentEvent.CalendarEventSoon) {
        if (event.minutesUntil > 15) return

        val timeText = when {
            event.minutesUntil <= 1 -> "starting now"
            event.minutesUntil <= 5 -> "starts in ${event.minutesUntil} min"
            else -> "starts in ${event.minutesUntil} min"
        }

        addInsight(
            ProactiveInsightItem(
                message = "${event.eventTitle} $timeText",
                priority = InsightPriority.MEDIUM,
                agentType = AgentType.GENERAL,
                action = ProactiveAction.NavigateTo("calendar")
            )
        )
    }

    // ---- Rule: Reminder fired ----

    private fun handleReminderFired(event: AgentEvent.ReminderFired) {
        addInsight(
            ProactiveInsightItem(
                message = "Reminder: ${event.description}",
                priority = InsightPriority.HIGH,
                agentType = AgentType.REMINDER,
                action = ProactiveAction.NavigateTo("reminders/${event.reminderId}")
            )
        )
    }

    // ---- Rule: Media stopped after long session ----

    private fun handleMediaStateChanged(event: AgentEvent.MediaStateChanged) {
        if (event.isPlaying) {
            // Track the start of a play session
            if (mediaPlayStartTime == 0L) {
                mediaPlayStartTime = System.currentTimeMillis()
            }
            lastMediaTitle = event.title
            lastMediaArtist = event.artist
        } else {
            // Playback stopped -- check if it was a long session
            if (mediaPlayStartTime > 0L) {
                val sessionDuration = System.currentTimeMillis() - mediaPlayStartTime
                if (sessionDuration >= LONG_PLAY_SESSION_MS && lastMediaTitle != null) {
                    val artistText = if (lastMediaArtist != null) " by ${lastMediaArtist}" else ""
                    addInsight(
                        ProactiveInsightItem(
                            message = "Continue listening to ${lastMediaTitle}$artistText?",
                            priority = InsightPriority.LOW,
                            agentType = AgentType.MEDIA,
                            action = ProactiveAction.SendCommand("play ${lastMediaTitle ?: ""}")
                        )
                    )
                }
            }
            mediaPlayStartTime = 0L
        }
    }

    // ---- Rule: System events ----

    private fun handleSystemEvent(event: AgentEvent.SystemEvent) {
        when (event.type) {
            SystemEventType.BATTERY_LOW -> {
                addInsight(
                    ProactiveInsightItem(
                        message = "Battery low. Consider plugging in.",
                        priority = InsightPriority.MEDIUM,
                        agentType = AgentType.GENERAL,
                        action = ProactiveAction.DismissOnly
                    )
                )
            }

            SystemEventType.BLUETOOTH_CONNECTED -> {
                addInsight(
                    ProactiveInsightItem(
                        message = "Bluetooth device connected. Play music?",
                        priority = InsightPriority.LOW,
                        agentType = AgentType.MEDIA,
                        action = ProactiveAction.SendCommand("play music")
                    )
                )
            }

            // Other system events do not generate insights currently
            SystemEventType.CHARGING_STARTED,
            SystemEventType.CHARGING_STOPPED,
            SystemEventType.BLUETOOTH_DISCONNECTED,
            SystemEventType.SCREEN_ON,
            SystemEventType.SCREEN_OFF,
            SystemEventType.BOOT_COMPLETED -> { /* no insight */ }
        }
    }

    // ---- Rule: Agent-emitted proactive insight ----

    private fun handleAgentInsight(event: AgentEvent.ProactiveInsight) {
        addInsight(
            ProactiveInsightItem(
                message = event.message,
                priority = event.priority,
                agentType = event.agentType,
                action = ProactiveAction.DismissOnly
            )
        )
    }

    // -------------------------------------------------------------------------------------
    // Insight management
    // -------------------------------------------------------------------------------------

    /**
     * Add an insight to the list, respecting rate limits and max capacity.
     */
    private fun addInsight(insight: ProactiveInsightItem) {
        // Rate limiting: check if this agent has emitted too recently
        val now = System.currentTimeMillis()
        val lastTime = lastInsightTime[insight.agentType] ?: 0L
        if (now - lastTime < RATE_LIMIT_MS) {
            // Rate limited -- skip this insight unless it is HIGH priority
            if (insight.priority != InsightPriority.HIGH) return
        }

        lastInsightTime[insight.agentType] = now

        val current = _proactiveInsights.value.toMutableList()

        // Add the new insight
        current.add(insight)

        // Sort: HIGH first, then MEDIUM, then LOW; within same priority, newest first
        current.sortWith(
            compareBy<ProactiveInsightItem> { it.priority.ordinal }
                .thenByDescending { it.timestamp }
        )

        // Cap to max size
        if (current.size > MAX_INSIGHTS) {
            // Remove oldest LOW priority insights first
            val trimmed = current.take(MAX_INSIGHTS)
            _proactiveInsights.value = trimmed
        } else {
            _proactiveInsights.value = current
        }
    }

    /**
     * Remove insights older than [INSIGHT_EXPIRY_MS].
     */
    private fun expireOldInsights() {
        val cutoff = System.currentTimeMillis() - INSIGHT_EXPIRY_MS
        val current = _proactiveInsights.value
        val filtered = current.filter { it.timestamp > cutoff }
        if (filtered.size != current.size) {
            _proactiveInsights.value = filtered
        }
    }

    // -------------------------------------------------------------------------------------
    // Helpers
    // -------------------------------------------------------------------------------------

    private fun truncate(text: String, maxLength: Int): String {
        return if (text.length <= maxLength) text else text.take(maxLength - 1) + "\u2026"
    }
}
